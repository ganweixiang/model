<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ç¥é»„ç¬¨çŒªæ–°å¹´å¿«ä¹</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-capable" content="yes">
  <meta name="theme-color" content="#000000">
  <link rel="shortcut icon" type="image/png" href="https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/firework-burst-icon.png">
  <link rel="icon" type="image/png" href="https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/firework-burst-icon.png">
  <link rel="apple-touch-icon-precomposed" href="https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/firework-burst-icon.png">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="msapplication-TileImage" content="https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/firework-burst-icon.png">
  <link href="https://fonts.googleapis.com/css?family=Russo+One" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
  <style>
    * {
      position: relative;
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    html {
      background-color: #000;
    }

    body {
      overflow: hidden;
      color: rgba(255, 255, 255, 0.5);
      font-family: "Russo One", arial, sans-serif;
      line-height: 1.25;
      letter-spacing: 0.06em;
    }

    .hide {
      opacity: 0;
      visibility: hidden;
    }

    .remove {
      display: none;
    }

    .blur {
      filter: blur(12px);
    }

    /* æ–‡å­—ç²’å­ç”»å¸ƒæ ·å¼ */
    #text-canvas {
      position: absolute !important;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      z-index: 2 !important;
      pointer-events: none !important;
    }

    /* çƒŸèŠ±å®¹å™¨æ ·å¼ */
    #stage-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      box-sizing: initial;
      border: 1px solid #222;
      margin: -1px;
      z-index: 1;
    }

    #canvas-container {
      width: 100%;
      height: 100%;
      transition: filter 0.3s;
    }
    
    #canvas-container canvas {
      position: absolute;
      mix-blend-mode: lighten;
    }

    /* å¯åŠ¨æŒ‰é’®æ ·å¼ */
    .start-btn {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: linear-gradient(45deg, #ff6b6b, #ffa726);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      z-index: 10000;
      box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
      transition: all 0.3s ease;
      font-family: 'Arial', sans-serif;
      font-weight: bold;
      letter-spacing: 2px;
    }

    .start-btn:hover {
      transform: translate(-50%, -50%) scale(1.05);
      box-shadow: 0 15px 40px rgba(255, 107, 107, 0.6);
      background: linear-gradient(45deg, #ffa726, #ff6b6b);
    }

    .start-btn:active {
      transform: translate(-50%, -50%) scale(0.98);
    }

    /* æ§åˆ¶é¢æ¿æ ·å¼ */
    #controls {
      position: absolute;
      top: 0;
      width: 100%;
      padding-bottom: 50px;
      display: flex;
      justify-content: space-between;
      transition: opacity 0.3s, visibility 0.3s;
      z-index: 3;
    }
    
    @media (min-width: 800px) {
      #controls {
        visibility: visible;
      }
      #controls.hide:hover {
        opacity: 1;
      }
    }

    #menu {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
      background-color: rgba(0, 0, 0, 0.42);
      transition: opacity 0.3s, visibility 0.3s;
      z-index: 4;
    }
    
    #menu__header {
      padding: 20px 0 44px;
      font-size: 2em;
      text-transform: uppercase;
    }
    
    #menu form {
      width: 240px;
      padding: 0 20px;
      overflow: auto;
    }
    
    #menu .form-option {
      margin: 20px 0;
    }
    
    #menu .form-option label {
      text-transform: uppercase;
    }
    
    #menu .form-option--select label {
      display: block;
      margin-bottom: 6px;
    }
    
    #menu .form-option--select select {
      display: block;
      width: 100%;
      height: 30px;
      font-size: 1rem;
      font-family: "Russo One", arial, sans-serif;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 0.06em;
      background-color: transparent;
      border: 1px solid rgba(255, 255, 255, 0.5);
    }
    
    #menu .form-option--select select option {
      background-color: black;
    }
    
    #menu .form-option--checkbox label {
      display: flex;
      align-items: center;
      transition: opacity 0.3s;
      -webkit-user-select: none;
         -moz-user-select: none;
          -ms-user-select: none;
              user-select: none;
    }
    
    #menu .form-option--checkbox input {
      display: block;
      width: 20px;
      height: 20px;
      margin-right: 8px;
      opacity: 0.5;
    }
    
    @media (max-width: 800px) {
      #menu .form-option select, #menu .form-option input {
        outline: none;
      }
    }

    #close-menu-btn {
      position: absolute;
      top: 0;
      right: 0;
    }

    .btn {
      opacity: 0.16;
      width: 44px;
      height: 44px;
      display: flex;
      -webkit-user-select: none;
         -moz-user-select: none;
          -ms-user-select: none;
              user-select: none;
      cursor: default;
      transition: opacity 0.3s;
    }
    
    .btn--bright {
      opacity: 0.5;
    }
    
    @media (min-width: 800px) {
      .btn:hover {
        opacity: 0.32;
      }
      .btn--bright:hover {
        opacity: 0.75;
      }
    }
    
    .btn svg {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>

<!-- SVG Spritesheet -->
<div style="height: 0; width: 0; position: absolute; visibility: hidden;">
  <svg xmlns="http://www.w3.org/2000/svg">
    <symbol id="icon-play" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></symbol>
    <symbol id="icon-pause" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></symbol>
    <symbol id="icon-close" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></symbol>
    <symbol id="icon-settings" viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38 2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></symbol>
    <symbol id="icon-shutter-fast" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></symbol>
    <symbol id="icon-shutter-slow" viewBox="0 0 24 24"><path d="M1 5h2v14H1zm4 0h2v14H5zm17 0H10c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zM11 17l2.5-3.15L15.29 16l2.5-3.22L21 17H11z"/></symbol>
  </svg>
</div>

<!-- å¯åŠ¨æŒ‰é’® -->
<button id="startBtn" class="start-btn">å¼€å¯æ–°å¹´ç¥ç¦ğŸ‰</button>

<!-- æ–‡å­—ç²’å­ç”»å¸ƒ -->
<canvas id="text-canvas"></canvas>

<!-- çƒŸèŠ±ç³»ç»Ÿ -->
<div id="stage-container" class="remove">
  <div id="canvas-container">
    <canvas id="trails-canvas"></canvas>
    <canvas id="main-canvas"></canvas>
  </div>
  
  <div id="controls" class="hide">
    <!-- æ§åˆ¶æŒ‰é’®ï¼ˆå·²ç®€åŒ–ï¼‰ -->
  </div>
  
  <div id="menu" class="hide">
    <div id="close-menu-btn" class="btn btn--bright">
      <svg fill="white" width="24" height="24"><use href="#icon-close"></use></svg>
    </div>
    <div id="menu__header">Settings</div>
    <form>
      <div class="form-option form-option--select">
        <label>Shell Type</label>
        <select id="shell-type"></select>
      </div>
      <div class="form-option form-option--select">
        <label>Shell Size</label>
        <select id="shell-size"></select>
      </div>
      <div class="form-option form-option--checkbox">
        <label id="auto-launch-label"><input id="auto-launch" type="checkbox" /><span>Auto Fire</span></label>
      </div>
      <div class="form-option form-option--checkbox">
        <label id="finale-mode-label"><input id="finale-mode" type="checkbox" /><span>Finale Mode</span></label>
      </div>
      <div class="form-option form-option--checkbox">
        <label id="hide-controls-label"><input id="hide-controls" type="checkbox" /><span>Hide Controls</span></label>
      </div>
    </form>
  </div>
</div>

<!-- èƒŒæ™¯éŸ³ä¹ -->
<audio id="myAudio" controls style="display: none;">
  <source src="https://music.163.com/song/media/outer/url?id=1910279208.mp3" type="audio/mpeg">
</audio>

<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/fscreen%401.0.1.js'></script>
<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/Stage%400.1.4.js'></script>
<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/MyMath.js'></script>

<script>
// ==================== ç²’å­æ–‡å­—ç³»ç»Ÿ ====================
var ParticleTextSystem = (function() {
  'use strict';
  
  // æ£€æµ‹ç§»åŠ¨ç«¯
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // ç»˜å›¾ç³»ç»Ÿ
  var Drawing = (function() {
    var canvas,
        context,
        renderFn,
        requestFrame = window.requestAnimationFrame ||
                     window.webkitRequestAnimationFrame ||
                     window.mozRequestAnimationFrame ||
                     window.oRequestAnimationFrame ||
                     window.msRequestAnimationFrame ||
                     function(callback) {
                       window.setTimeout(callback, 1000 / 60);
                     };

    return {
      init: function() {
        canvas = document.getElementById('text-canvas');
        context = canvas.getContext('2d');
        this.adjustCanvas();
        
        window.addEventListener('resize', function() {
          Drawing.adjustCanvas();
        });
      },

      loop: function(fn) {
        renderFn = !renderFn ? fn : renderFn;
        this.clearFrame();
        renderFn();
        requestFrame.call(window, this.loop.bind(this));
      },

      adjustCanvas: function() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      },

      clearFrame: function() {
        context.clearRect(0, 0, canvas.width, canvas.height);
      },

      getArea: function() {
        return { w: canvas.width, h: canvas.height };
      },

      drawCircle: function(p, c) {
        context.fillStyle = c.render();
        context.beginPath();
        context.arc(p.x, p.y, p.z, 0, 2 * Math.PI, true);
        context.closePath();
        context.fill();
      }
    };
  }());

  // ç‚¹å¯¹è±¡
  var Point = function(args) {
    this.x = args.x;
    this.y = args.y;
    this.z = args.z;
    this.a = args.a;
    this.h = args.h;
  };

  // é¢œè‰²å¯¹è±¡
  var Color = function(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  };

  Color.prototype = {
    render: function() {
      return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + this.a + ')';
    }
  };

  // ç²’å­å¯¹è±¡
  var Dot = function(x, y) {
    this.p = new Point({
      x: x,
      y: y,
      z: isMobile ? 3 : 5, // ç§»åŠ¨ç«¯ç²’å­æ›´å°
      a: 1,
      h: 0
    });
  
    this.e = isMobile ? 0.12 : 0.07; // ç§»åŠ¨ç«¯ç§»åŠ¨é€Ÿåº¦æ›´å¿«
    this.s = true;
    this.c = new Color(173, 216, 230, this.p.a); // æµ…è“è‰²ç²’å­
    this.t = this.clone();
    this.q = [];
  };

  Dot.prototype = {
    clone: function() {
      return new Point({
        x: this.x,
        y: this.y,
        z: this.z,
        a: this.a,
        h: this.h
      });
    },

    _draw: function() {
      this.c.a = this.p.a;
      Drawing.drawCircle(this.p, this.c);
    },

    _moveTowards: function(n) {
      var details = this.distanceTo(n, true),
          dx = details[0],
          dy = details[1],
          d = details[2],
          e = this.e * d;

      if (this.p.h === -1) {
        this.p.x = n.x;
        this.p.y = n.y;
        return true;
      }

      if (d > 1) {
        this.p.x -= ((dx / d) * e);
        this.p.y -= ((dy / d) * e);
      } else {
        if (this.p.h > 0) {
          this.p.h--;
        } else {
          return true;
        }
      }

      return false;
    },

    _update: function() {
      if (this._moveTowards(this.t)) {
        var p = this.q.shift();

        if (p) {
          this.t.x = p.x || this.p.x;
          this.t.y = p.y || this.p.y;
          this.t.z = p.z || this.p.z;
          this.t.a = p.a || this.p.a;
          this.p.h = p.h || 0;
        } else {
          if (this.s) {
            this.p.x -= Math.sin(Math.random() * 3.142);
            this.p.y -= Math.sin(Math.random() * 3.142);
          } else {
            this.move(new Point({
              x: this.p.x + (Math.random() * 50) - 25,
              y: this.p.y + (Math.random() * 50) - 25,
            }));
          }
        }
      }

      var d = this.p.a - this.t.a;
      this.p.a = Math.max(0.1, this.p.a - (d * 0.05));
      d = this.p.z - this.t.z;
      this.p.z = Math.max(1, this.p.z - (d * 0.05));
    },

    distanceTo: function(n, details) {
      var dx = this.p.x - n.x,
          dy = this.p.y - n.y,
          d = Math.sqrt(dx * dx + dy * dy);

      return details ? [dx, dy, d] : d;
    },

    move: function(p, avoidStatic) {
      if (!avoidStatic || (avoidStatic && this.distanceTo(p) > 1)) {
        this.q.push(p);
      }
    },

    render: function() {
      this._update();
      this._draw();
    }
  };

  // å½¢çŠ¶æ„å»ºå™¨ - ç§»åŠ¨ç«¯é€‚é…ï¼šæ–‡å­—å˜å°ä½†ç²’å­å¯†åº¦ä¸å˜
  var ShapeBuilder = (function() {
    // ç§»åŠ¨ç«¯ä½¿ç”¨æ›´å°çš„é—´è·ï¼Œè¿™æ ·æ–‡å­—æ•´ä½“ä¼šå˜å°ï¼Œä½†ç²’å­å¯†åº¦ä¸å˜
    var gap = isMobile ? 6 : 13, // è¿›ä¸€æ­¥å‡å°ç§»åŠ¨ç«¯é—´è·
        shapeCanvas = document.createElement('canvas'),
        shapeContext = shapeCanvas.getContext('2d'),
        fontSize = isMobile ? 180 : 500, // è¿›ä¸€æ­¥å‡å°ç§»åŠ¨ç«¯å­—ä½“
        fontFamily = 'Arial, sans-serif';
  
    function fit() {
      // å¢åŠ ç”»å¸ƒå¤§å°ï¼Œç¡®ä¿æ–‡å­—æœ‰è¶³å¤Ÿç©ºé—´
      shapeCanvas.width = Math.floor(window.innerWidth / gap) * gap;
      shapeCanvas.height = Math.floor(window.innerHeight / gap) * gap;
      shapeContext.fillStyle = 'red';
      shapeContext.textBaseline = 'middle';
      shapeContext.textAlign = 'center';
    }
  
    function processCanvas() {
      var pixels = shapeContext.getImageData(0, 0, shapeCanvas.width, shapeCanvas.height).data,
          dots = [],
          x = 0,
          y = 0,
          fx = shapeCanvas.width,
          fy = shapeCanvas.height,
          w = 0,
          h = 0;
  
      for (var p = 0; p < pixels.length; p += (4 * gap)) {
        if (pixels[p + 3] > 0) {
          dots.push(new Point({
            x: x,
            y: y
          }));
  
          w = x > w ? x : w;
          h = y > h ? y : h;
          fx = x < fx ? x : fx;
          fy = y < fy ? y : fy;
        }
  
        x += gap;
  
        if (x >= shapeCanvas.width) {
          x = 0;
          y += gap;
          p += gap * 4 * shapeCanvas.width;
        }
      }
  
      return { dots: dots, w: w + fx, h: h + fy };
    }
  
    function setFontSize(s) {
      shapeContext.font = 'bold ' + s + 'px ' + fontFamily;
    }
  
    function isNumber(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
  
    function init() {
      fit();
      window.addEventListener('resize', fit);
    }
  
    init();
  
    return {
      letter: function(l) {
        var s = 0;
  
        setFontSize(fontSize);
        // ç§»åŠ¨ç«¯æ–‡å­—ç¼©æ”¾æ¯”ä¾‹è°ƒæ•´ï¼Œç¡®ä¿æ–‡å­—å®Œå…¨æ˜¾ç¤º
        s = Math.min(fontSize,
                    (shapeCanvas.width / shapeContext.measureText(l).width) * (isMobile ? 0.8 : 0.8) * fontSize,
                    (shapeCanvas.height / fontSize) * (isNumber(l) ? 0.8 : 0.35) * fontSize); // è°ƒæ•´é«˜åº¦é™åˆ¶
        setFontSize(s);
  
        shapeContext.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
        shapeContext.fillText(l, shapeCanvas.width / 2, shapeCanvas.height / 2);
  
        return processCanvas();
      }
    };
  }());

  // å½¢çŠ¶ç®¡ç†å™¨
  var Shape = (function() {
    var dots = [],
        width = 0,
        height = 0,
        cx = 0,
        cy = 0;

    function compensate() {
      var a = Drawing.getArea();
      cx = a.w / 2 - width / 2;
      cy = a.h / 2 - height / 2;
    }

    return {
      switchShape: function(n, fast) {
        var size,
            a = Drawing.getArea();

        width = n.w;
        height = n.h;
        compensate();

        if (n.dots.length > dots.length) {
          size = n.dots.length - dots.length;
          for (var d = 1; d <= size; d++) {
            dots.push(new Dot(a.w / 2, a.h / 2));
          }
        }

        var d = 0,
            i = 0;

        while (n.dots.length > 0) {
          i = Math.floor(Math.random() * n.dots.length);
          
          dots[d].e = fast ? 0.25 : (dots[d].s ? 0.14 : 0.11);

          if (dots[d].s) {
            dots[d].move(new Point({
              z: Math.random() * 20 + 10,
              a: Math.random(),
              h: 18
            }));
          } else {
            dots[d].move(new Point({
              z: Math.random() * 5 + 5,
              h: fast ? 18 : 30
            }));
          }

          dots[d].s = true;
          dots[d].move(new Point({
            x: n.dots[i].x + cx,
            y: n.dots[i].y + cy,
            a: 1,
            z: 5,
            h: 0
          }));

          n.dots = n.dots.slice(0, i).concat(n.dots.slice(i + 1));
          d++;
        }

        for (var i = d; i < dots.length; i++) {
          if (dots[i].s) {
            dots[i].move(new Point({
              z: Math.random() * 20 + 10,
              a: Math.random(),
              h: 20
            }));

            dots[i].s = false;
            dots[i].e = 0.04;
            dots[i].move(new Point({
              x: Math.random() * a.w,
              y: Math.random() * a.h,
              a: 0.3,
              z: Math.random() * 4,
              h: 0
            }));
          }
        }
      },

      render: function() {
        for (var d = 0; d < dots.length; d++) {
          dots[d].render();
        }
      },
      
      clear: function() {
        dots = [];
        Drawing.clearFrame();
      }
    };
  }());

  // åˆå§‹åŒ–ç²’å­æ–‡å­—ç³»ç»Ÿ
  function init() {
    Drawing.init();
    Drawing.loop(function() {
      Shape.render();
    });
  }

  // æ˜¾ç¤ºå€’è®¡æ—¶å’Œç¥ç¦è¯­ï¼ˆç§»åŠ¨ç«¯é€‚é…ï¼‰
  function startCountdownAndBlessings() {
    // å…ˆæ¸…ç©ºç°æœ‰ç²’å­
    Shape.clear();
    
    // å€’è®¡æ—¶åºåˆ—
    var countdownSequence = [5, 4, 3, 2, 1];
    var blessings = [
      "2026",
      "æ–°å¹´å¿«ä¹",
      "å¹³å®‰å–œä¹", 
      "å‡¡æ˜¯è¿‡å¾€",
      "çš†ä¸ºåºç« ",
      "ç¦èµ·æ–°å²",
      "ä¸‡äº‹é¡ºé‚",
      "ä¸‹ä¸€ä¸ª365å¤©",
      "ä¹Ÿè¦å¼€å¼€å¿ƒå¿ƒ",
      "æˆ‘æ°¸è¿œéƒ½åœ¨"
    ];
    
    var currentIndex = 0;
    var isCountdown = true;
    
    function showNext() {
      if (isCountdown) {
        if (currentIndex < countdownSequence.length) {
          var number = countdownSequence[currentIndex];
          Shape.switchShape(ShapeBuilder.letter(number.toString()), true);
          currentIndex++;
          setTimeout(showNext, 1000);
        } else {
          // å€’è®¡æ—¶ç»“æŸï¼Œå¼€å§‹æ˜¾ç¤ºç¥ç¦è¯­
          isCountdown = false;
          currentIndex = 0;
          setTimeout(showNext, 500);
        }
      } else {
        if (currentIndex < blessings.length) {
          var text = blessings[currentIndex];
          Shape.switchShape(ShapeBuilder.letter(text), true);
          currentIndex++;
          setTimeout(showNext, isMobile ? 1800 : 2000); // ç§»åŠ¨ç«¯æ˜¾ç¤ºæ—¶é—´ç¨é•¿
        } else {
          // æ˜¾ç¤ºå®Œæˆåï¼Œæ¸…ç©ºæ–‡å­—
          setTimeout(function() {
            Shape.clear();
          }, 5000);
        }
      }
    }
    
    showNext();
  }

  return {
    init: init,
    startCountdownAndBlessings: startCountdownAndBlessings
  };
})();

// ==================== çƒŸèŠ±ç³»ç»Ÿ ====================
'use strict';

// ä½¿ç”¨åŸæ¥çš„è®¾å¤‡æ£€æµ‹é€»è¾‘
const IS_MOBILE = window.innerWidth <= 640;
const IS_DESKTOP = window.innerWidth > 800;
const IS_HEADER = IS_DESKTOP && window.innerHeight < 300;
const MAX_WIDTH = 7680;
const MAX_HEIGHT = 4320;
const GRAVITY = 0.9;
let simSpeed = 1;

const COLOR = {
  Red: '#ff0043',
  Green: '#14fc56',
  Blue: '#1e7fff',
  Purple: '#e60aff',
  Gold: '#ffae00',
  White: '#ffffff'
};

const INVISIBLE = '_INVISIBLE_';

// äº¤äº’çŠ¶æ€ç®¡ç†
const store = {
  _listeners: new Set(),
  _dispatch() {
    this._listeners.forEach(listener => listener(this.state));
  },
  state: {
    paused: false,
    longExposure: false,
    menuOpen: false,
    config: {
      shell: 'Random',
      size: IS_DESKTOP && !IS_HEADER ? '3' : '1',
      autoLaunch: true,
      finale: false,
      hideControls: IS_HEADER
    }
  },
  setState(nextState) {
    this.state = Object.assign({}, this.state, nextState);
    this._dispatch();
    this.persist();
  },
  subscribe(listener) {
    this._listeners.add(listener);
    return () => this._listeners.remove(listener);
  },
  load() {
    if (localStorage.getItem('schemaVersion') === '1') {
      this.state.config.size = JSON.parse(localStorage.getItem('configSize'));
      this.state.config.hideControls = JSON.parse(localStorage.getItem('hideControls'));
    }
  },
  persist() {
    localStorage.setItem('schemaVersion', '1');
    localStorage.setItem('configSize', JSON.stringify(this.state.config.size));
    localStorage.setItem('hideControls', JSON.stringify(this.state.config.hideControls));
  }
};

if (!IS_HEADER) {
  store.load();
}

function toggleMenu(toggle) {
  if (typeof toggle === 'boolean') {
    store.setState({ menuOpen: toggle });
  } else {
    store.setState({ menuOpen: !store.state.menuOpen });
  }
}

function updateConfig(nextConfig) {
  nextConfig = nextConfig || getConfigFromDOM();
  store.setState({
    config: Object.assign({}, store.state.config, nextConfig)
  });
}

const canInteract = () => !store.state.paused && !store.state.menuOpen;
const shellNameSelector = () => store.state.config.shell;
const shellSizeSelector = () => +store.state.config.size;
const finaleSelector = () => store.state.config.finale;

// DOM èŠ‚ç‚¹
const appNodes = {
  stageContainer: '#stage-container',
  canvasContainer: '#canvas-container',
  controls: '#controls',
  menu: '#menu',
  shellType: '#shell-type',
  shellSize: '#shell-size',
  autoLaunch: '#auto-launch',
  autoLaunchLabel: '#auto-launch-label',
  finaleMode: '#finale-mode',
  finaleModeLabel: '#finale-mode-label',
  hideControls: '#hide-controls',
  hideControlsLabel: '#hide-controls-label'
};

Object.keys(appNodes).forEach(key => {
  appNodes[key] = document.querySelector(appNodes[key]);
});

// åˆå§‹åŒ–çƒŸèŠ±ç³»ç»Ÿ
function initFireworks() {
  appNodes.stageContainer.classList.remove('remove');
  
  // å¡«å……ä¸‹æ‹‰é€‰é¡¹
  let options = '';
  ['Random', 'Crackle', 'Crossette', 'Crysanthemum', 'Falling Leaves', 'Floral', 'Horse Tail', 'Palm', 'Ring', 'Willow'].forEach(opt => {
    options += `<option value="${opt}">${opt}</option>`;
  });
  appNodes.shellType.innerHTML = options;
  
  options = '';
  ['3"', '5"', '6"', '8"', '12"'].forEach((opt, i) => {
    options += `<option value="${i}">${opt}</option>`;
  });
  appNodes.shellSize.innerHTML = options;
  
  // åˆå§‹æ¸²æŸ“
  renderApp(store.state);
  
  // å¼€å§‹è‡ªåŠ¨å‘å°„çƒŸèŠ±
  if (store.state.config.autoLaunch) {
    autoLaunchTime = startSequence();
  }
}

function renderApp(state) {
  appNodes.controls.classList.toggle('hide', state.menuOpen || state.config.hideControls);
  appNodes.canvasContainer.classList.toggle('blur', state.menuOpen);
  appNodes.menu.classList.toggle('hide', !state.menuOpen);
  appNodes.finaleModeLabel.style.opacity = state.config.autoLaunch ? 1 : 0.32;
  appNodes.shellType.value = state.config.shell;
  appNodes.shellSize.value = state.config.size;
  appNodes.autoLaunch.checked = state.config.autoLaunch;
  appNodes.finaleMode.checked = state.config.finale;
  appNodes.hideControls.checked = state.config.hideControls;
}

function getConfigFromDOM() {
  return {
    shell: appNodes.shellType.value,
    size: appNodes.shellSize.value,
    autoLaunch: appNodes.autoLaunch.checked,
    finale: appNodes.finaleMode.checked,
    hideControls: appNodes.hideControls.checked
  };
}

const updateConfigNoEvent = () => updateConfig();
appNodes.shellType.addEventListener('input', updateConfigNoEvent);
appNodes.shellSize.addEventListener('input', updateConfigNoEvent);
appNodes.autoLaunchLabel.addEventListener('click', () => setTimeout(updateConfig, 0));
appNodes.finaleModeLabel.addEventListener('click', () => setTimeout(updateConfig, 0));
appNodes.hideControlsLabel.addEventListener('click', () => setTimeout(updateConfig, 0));

store.subscribe(renderApp);

// é¢œè‰²ç›¸å…³
const COLOR_NAMES = Object.keys(COLOR);
const COLOR_CODES = COLOR_NAMES.map(colorName => COLOR[colorName]);
const COLOR_CODES_W_INVIS = [...COLOR_CODES, INVISIBLE];
const COLOR_TUPLES = {};
COLOR_CODES.forEach(hex => {
  COLOR_TUPLES[hex] = {
    r: parseInt(hex.substr(1, 2), 16),
    g: parseInt(hex.substr(3, 2), 16),
    b: parseInt(hex.substr(5, 2), 16),
  };
});

function randomColorSimple() {
  return COLOR_CODES[Math.random() * COLOR_CODES.length | 0];
}

let lastColor;
function randomColor(options) {
  const notSame = options && options.notSame;
  const notColor = options && options.notColor;
  const limitWhite = options && options.limitWhite;
  let color = randomColorSimple();
  
  if (limitWhite && color === COLOR.White && Math.random() < 0.6) {
    color = randomColorSimple();
  }
  
  if (notSame) {
    while (color === lastColor) {
      color = randomColorSimple();
    }
  }
  else if (notColor) {
    while (color === notColor) {
      color = randomColorSimple();
    }
  }
  
  lastColor = color;
  return color;
}

function whiteOrGold() {
  return Math.random() < 0.5 ? COLOR.Gold : COLOR.White;
}

const PI_2 = Math.PI * 2;
const PI_HALF = Math.PI * 0.5;

const trailsStage = new Stage('trails-canvas');
const mainStage = new Stage('main-canvas');
const stages = [trailsStage, mainStage];

// åˆå§‹åŒ–è½¨è¿¹ç”»å¸ƒ
trailsStage.ctx.fillStyle = '#000';
trailsStage.ctx.fillRect(0, 0, trailsStage.width, trailsStage.height);

// Shell ç±»å‹å®šä¹‰ï¼ˆä¿æŒåŸæ¥çš„å¤§å°å’Œå¯†åº¦ï¼‰
const crysanthemumShell = (size=1) => {
  const glitter = Math.random() < 0.25;
  const singleColor = Math.random() < 0.68;
  const color = singleColor ? randomColor({ limitWhite: true }) : [randomColor(), randomColor({ notSame: true })];
  const pistil = singleColor && Math.random() < 0.42;
  const pistilColor = (color === COLOR.White || color === COLOR.Gold) ? randomColor({ notColor: color }) : whiteOrGold();
  const streamers = !pistil && color !== COLOR.White && Math.random() < 0.42;
  
  return {
    size: 300 + size * 100,
    starLife: 900 + size * 200,
    starDensity: glitter ? 1.1 : 1.5,
    color,
    glitter: glitter ? 'light' : '',
    glitterColor: whiteOrGold(),
    pistil,
    pistilColor,
    streamers
  };
};

const palmShell = (size=1) => ({
  size: 250 + size * 75,
  starDensity: 0.6,
  starLife: 1800 + size * 200,
  glitter: 'heavy'
});

const ringShell = (size=1) => {
  const color = randomColor();
  const pistil = Math.random() < 0.75;
  return {
    ring: true,
    color,
    size: 300 + size * 100,
    starLife: 900 + size * 200,
    starCount: 2.2 * PI_2 * (size+1),
    pistil,
    pistilColor: (color === COLOR.White || color === COLOR.Gold) ? randomColor({ notColor: color }) : whiteOrGold(),
    glitter: !pistil ? 'light' : '',
    glitterColor: color === COLOR.Gold ? COLOR.Gold : COLOR.White
  };
};

const crossetteShell = (size=1) => {
  const color = randomColor({ limitWhite: true });
  return {
    size: 300 + size * 100,
    starLife: 900 + size * 200,
    starLifeVariation: 0.22,
    color,
    crossette: true,
    pistil: Math.random() < 0.5,
    pistilColor: (color === COLOR.White || color === COLOR.Gold) ? randomColor({ notColor: color }) : whiteOrGold()
  };
};

const floralShell = (size=1) => ({
  size: 300 + size * 120,
  starDensity: 0.38,
  starLife: 500 + size * 50,
  starLifeVariation: 0.5,
  color: Math.random() < 0.65 ? 'random' : (Math.random() < 0.15 ? randomColor() : [randomColor(), randomColor({ notSame: true })]),
  floral: true
});

const fallingLeavesShell = (size=1) => ({
  color: INVISIBLE,
  size: 300 + size * 120,
  starDensity: 0.38,
  starLife: 500 + size * 50,
  starLifeVariation: 0.5,
  glitter: 'medium',
  glitterColor: COLOR.Gold,
  fallingLeaves: true
});

const willowShell = (size=1) => ({
  size: 300 + size * 100,
  starDensity: 0.7,
  starLife: 3000 + size * 300,
  glitter: 'willow',
  glitterColor: COLOR.Gold,
  color: INVISIBLE
});

const crackleShell = (size=1) => {
  const color = Math.random() < 0.75 ? COLOR.Gold : randomColor();
  return {
    size: 380 + size * 75,
    starDensity: 1,
    starLife: 600 + size * 100,
    starLifeVariation: 0.32,
    glitter: 'light',
    glitterColor: COLOR.Gold,
    color,
    crackle: true,
    pistil: Math.random() < 0.65,
    pistilColor: (color === COLOR.White || color === COLOR.Gold) ? randomColor({ notColor: color }) : whiteOrGold()
  };
};

const horsetailShell = (size=1) => {
  const color = randomColor();
  return {
    horsetail: true,
    color,
    size: 250 + size * 38,
    starDensity: 0.85 + size * 0.1,
    starLife: 2500 + size * 300,
    glitter: 'medium',
    glitterColor: Math.random() < 0.5 ? whiteOrGold() : color
  };
};

function randomShellName() {
  return Math.random() < 0.6 ? 'Crysanthemum' : shellNames[(Math.random() * (shellNames.length - 1) + 1) | 0 ];
}

function randomShell(size) {
  return shellTypes[randomShellName()](size);
}

function shellFromConfig(size) {
  return shellTypes[shellNameSelector()](size);
}

const shellTypes = {
  'Random': randomShell,
  'Crackle': crackleShell,
  'Crossette': crossetteShell,
  'Crysanthemum': crysanthemumShell,
  'Falling Leaves': fallingLeavesShell,
  'Floral': floralShell,
  'Horse Tail': horsetailShell,
  'Palm': palmShell,
  'Ring': ringShell,
  'Willow': willowShell
};

const shellNames = Object.keys(shellTypes);

function fitShellPositionInBoundsH(position) {
  const edge = 0.18;
  return (1 - edge*2) * position + edge;
}

function fitShellPositionInBoundsV(position) {
  return position * 0.75;
}

function getRandomShellPositionH() {
  return fitShellPositionInBoundsH(Math.random());
}

function getRandomShellPositionV() {
  return fitShellPositionInBoundsV(Math.random());
}

function getRandomShellSize() {
  const baseSize = shellSizeSelector();
  const maxVariance = Math.min(2.5, baseSize);
  const variance = Math.random() * maxVariance;
  const size = baseSize - variance;
  const height = maxVariance === 0 ? Math.random() : 1 - (variance / maxVariance);
  const centerOffset = Math.random() * (1 - height * 0.65) * 0.5;
  const x = Math.random() < 0.5 ? 0.5 - centerOffset : 0.5 + centerOffset;
  return {
    size,
    x: fitShellPositionInBoundsH(x),
    height: fitShellPositionInBoundsV(height)
  };
}

function launchShellFromConfig(event) {
  const shell = new Shell(shellFromConfig(shellSizeSelector()));
  const w = mainStage.width;
  const h = mainStage.height;
  shell.launch(
    event ? event.x / w : getRandomShellPositionH(),
    event ? 1 - event.y / h : getRandomShellPositionV()
  );
}

// åºåˆ—å‡½æ•°
function seqRandomShell() {
  const size = getRandomShellSize();
  const shell = new Shell(shellFromConfig(size.size));
  shell.launch(size.x, size.height);
  
  const additionalShells = 2;
  for (let i = 0; i < additionalShells; i++) {
    const extraSize = getRandomShellSize();
    const extraShell = new Shell(shellFromConfig(extraSize.size));
    extraShell.launch(extraSize.x, extraSize.height);
  }
  
  let extraDelay = shell.starLife;
  if (shell.fallingLeaves) {
    extraDelay = 4000;
  }
  
  return 400 + Math.random() * 300 + extraDelay;
}

function seqTwoRandom() {
  const size1 = getRandomShellSize();
  const size2 = getRandomShellSize();
  const shell1 = new Shell(shellFromConfig(size1.size));
  const shell2 = new Shell(shellFromConfig(size2.size));
  const leftOffset = Math.random() * 0.2 - 0.1;
  const rightOffset = Math.random() * 0.2 - 0.1;
  
  shell1.launch(0.3 + leftOffset, size1.height);
  shell2.launch(0.7 + rightOffset, size2.height);
  
  const additionalShells = 2;
  for (let i = 0; i < additionalShells; i++) {
    const extraSize = getRandomShellSize();
    const extraShell = new Shell(shellFromConfig(extraSize.size));
    extraShell.launch(0.5 + (Math.random() * 0.4 - 0.2), extraSize.height);
  }
  
  let extraDelay = Math.max(shell1.starLife, shell2.starLife);
  if (shell1.fallingLeaves || shell2.fallingLeaves) {
    extraDelay = 4000;
  }
  
  return 400 + Math.random() * 300 + extraDelay;
}

const sequences = [
  seqRandomShell,
  seqTwoRandom
];

let isFirstSeq = true;
const finaleCount = 60;
let currentFinaleCount = 0;

function startSequence() {
  if (isFirstSeq) {
    isFirstSeq = false;
    const shell = new Shell(crysanthemumShell(shellSizeSelector()));
    shell.launch(0.5, 0.5);
    
    const extraShell = new Shell(crysanthemumShell(shellSizeSelector()));
    extraShell.launch(0.3, 0.4);
    const extraShell2 = new Shell(crysanthemumShell(shellSizeSelector()));
    extraShell2.launch(0.7, 0.6);
    
    return 500;
  }
  
  if (finaleSelector()) {
    seqRandomShell();
    if (currentFinaleCount < finaleCount) {
      currentFinaleCount++;
      return 100;
    } else {
      currentFinaleCount = 0;
      return 500;
    }
  }
  
  const rand = Math.random();
  if (rand < 0.7) {
    return seqRandomShell();
  } else {
    return seqTwoRandom();
  }
}

let activePointerCount = 0;
let isUpdatingSpeed = false;

function handlePointerStart(event) {
  activePointerCount++;
  if (!canInteract()) return;
  
  if (updateSpeedFromEvent(event)) {
    isUpdatingSpeed = true;
  } else if (event.onCanvas) {
    launchShellFromConfig(event);
    
    const w = mainStage.width;
    const h = mainStage.height;
    for (let i = 0; i < 2; i++) {
      const shell = new Shell(shellFromConfig(shellSizeSelector()));
      shell.launch(
        getRandomShellPositionH(),
        getRandomShellPositionV()
      );
    }
  }
}

function handlePointerEnd(event) {
  activePointerCount--;
  isUpdatingSpeed = false;
}

function handlePointerMove(event) {
  if (!canInteract()) return;
  if (isUpdatingSpeed) {
    updateSpeedFromEvent(event);
  }
}

function handleKeydown(event) {
  if (event.keyCode === 27) {
    toggleMenu(false);
  }
}

mainStage.addEventListener('pointerstart', handlePointerStart);
mainStage.addEventListener('pointerend', handlePointerEnd);
mainStage.addEventListener('pointermove', handlePointerMove);
window.addEventListener('keydown', handleKeydown);
window.addEventListener('touchend', (event) => !IS_DESKTOP && fscreen.requestFullscreen(document.documentElement));

function handleResize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  const containerW = Math.min(w, MAX_WIDTH);
  const containerH = w <= 420 ? h : Math.min(h, MAX_HEIGHT);
  
  appNodes.stageContainer.style.width = containerW + 'px';
  appNodes.stageContainer.style.height = containerH + 'px';
  stages.forEach(stage => stage.resize(containerW, containerH));
}

handleResize();
window.addEventListener('resize', handleResize);

let speedBarOpacity = 0;
let autoLaunchTime = 0;

function updateSpeedFromEvent(event) {
  if (isUpdatingSpeed || event.y >= mainStage.height - 44) {
    const edge = 16;
    const newSpeed = (event.x - edge) / (mainStage.width - edge * 2);
    simSpeed = Math.min(Math.max(newSpeed, 0), 1);
    speedBarOpacity = 1;
    return true;
  }
  return false;
}

function updateGlobals(timeStep, lag) {
  if (!isUpdatingSpeed) {
    speedBarOpacity -= lag / 30;
    if (speedBarOpacity < 0) {
      speedBarOpacity = 0;
    }
  }
  
  if (store.state.config.autoLaunch) {
    autoLaunchTime -= timeStep;
    if (autoLaunchTime <= 0) {
      autoLaunchTime = startSequence();
    }
  }
}

function update(frameTime, lag) {
  if (!canInteract()) return;
  const { width, height } = mainStage;
  const timeStep = frameTime * simSpeed;
  const speed = simSpeed * lag;
  
  updateGlobals(timeStep, lag);
  
  const starDrag = 1 - (1 - Star.airDrag) * speed;
  const starDragHeavy = 1 - (1 - Star.airDragHeavy) * speed;
  const sparkDrag = 1 - (1 - Spark.airDrag) * speed;
  const gAcc = timeStep / 1000 * GRAVITY;
  
  COLOR_CODES_W_INVIS.forEach(color => {
    // æ›´æ–°æ˜Ÿæ˜Ÿ
    Star.active[color].forEach((star, i, stars) => {
      star.life -= timeStep;
      if (star.life <= 0) {
        stars.splice(i, 1);
        Star.returnInstance(star);
      } else {
        star.prevX = star.x;
        star.prevY = star.y;
        star.x += star.speedX * speed;
        star.y += star.speedY * speed;
        
        if (!star.heavy) {
          star.speedX *= starDrag;
          star.speedY *= starDrag;
        } else {
          star.speedX *= starDragHeavy;
          star.speedY *= starDragHeavy;
        }
        
        star.speedY += gAcc;
        
        if (star.spinRadius) {
          star.spinAngle += star.spinSpeed * speed;
          star.x += Math.sin(star.spinAngle) * star.spinRadius * speed;
          star.y += Math.cos(star.spinAngle) * star.spinRadius * speed;
        }
        
        if (star.sparkFreq) {
          star.sparkTimer -= timeStep;
          while (star.sparkTimer < 0) {
            star.sparkTimer += star.sparkFreq;
            Spark.add(
              star.x,
              star.y,
              star.sparkColor,
              Math.random() * PI_2,
              Math.random() * star.sparkSpeed,
              star.sparkLife * 0.8 + Math.random() * star.sparkLifeVariation * star.sparkLife
            );
          }
        }
      }
    });
    
    // æ›´æ–°ç«èŠ±
    Spark.active[color].forEach((spark, i, sparks) => {
      spark.life -= timeStep;
      if (spark.life <= 0) {
        sparks.splice(i, 1);
        Spark.returnInstance(spark);
      } else {
        spark.prevX = spark.x;
        spark.prevY = spark.y;
        spark.x += spark.speedX * speed;
        spark.y += spark.speedY * speed;
        spark.speedX *= sparkDrag;
        spark.speedY *= sparkDrag;
        spark.speedY += gAcc;
      }
    });
  });
  
  render(speed);
}

function render(speed) {
  const { dpr, width, height } = mainStage;
  const trailsCtx = trailsStage.ctx;
  const mainCtx = mainStage.ctx;
  
  colorSky(speed);
  
  trailsCtx.scale(dpr, dpr);
  mainCtx.scale(dpr, dpr);
  
  trailsCtx.globalCompositeOperation = 'source-over';
  trailsCtx.fillStyle = `rgba(0, 0, 0, ${store.state.longExposure ? 0.25 : 0.2 * speed})`;
  trailsCtx.fillRect(0, 0, width, height);
  
  trailsCtx.globalCompositeOperation = 'lighten';
  mainCtx.clearRect(0, 0, width, height);
  
  // ç»˜åˆ¶çˆ†ç‚¸é—ªå…‰
  while (BurstFlash.active.length) {
    const bf = BurstFlash.active.pop();
    const burstGradient = trailsCtx.createRadialGradient(bf.x, bf.y, 0, bf.x, bf.y, bf.radius);
    burstGradient.addColorStop(0.05, 'white');
    burstGradient.addColorStop(0.25, 'rgba(255, 160, 20, 0.2)');
    burstGradient.addColorStop(1, 'rgba(255, 160, 20, 0)');
    trailsCtx.fillStyle = burstGradient;
    trailsCtx.fillRect(bf.x - bf.radius, bf.y - bf.radius, bf.radius * 2, bf.radius * 2);
    BurstFlash.returnInstance(bf);
  }
  
  // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
  trailsCtx.lineWidth = Star.drawWidth;
  trailsCtx.lineCap = 'round';
  mainCtx.strokeStyle = '#fff';
  mainCtx.lineWidth = 1;
  mainCtx.beginPath();
  
  COLOR_CODES.forEach(color => {
    const stars = Star.active[color];
    trailsCtx.strokeStyle = color;
    trailsCtx.beginPath();
    
    stars.forEach(star => {
      trailsCtx.moveTo(star.x, star.y);
      trailsCtx.lineTo(star.prevX, star.prevY);
      mainCtx.moveTo(star.x, star.y);
      mainCtx.lineTo(star.x - star.speedX * 1.6, star.y - star.speedY * 1.6);
    });
    
    trailsCtx.stroke();
  });
  
  mainCtx.stroke();
  
  // ç»˜åˆ¶ç«èŠ±
  trailsCtx.lineWidth = Spark.drawWidth;
  trailsCtx.lineCap = 'butt';
  
  COLOR_CODES.forEach(color => {
    const sparks = Spark.active[color];
    trailsCtx.strokeStyle = color;
    trailsCtx.beginPath();
    
    sparks.forEach(spark => {
      trailsCtx.moveTo(spark.x, spark.y);
      trailsCtx.lineTo(spark.prevX, spark.prevY);
    });
    
    trailsCtx.stroke();
  });
  
  // ç»˜åˆ¶é€Ÿåº¦æ¡
  if (speedBarOpacity) {
    const speedBarHeight = 6;
    mainCtx.globalAlpha = speedBarOpacity;
    mainCtx.fillStyle = COLOR.Blue;
    mainCtx.fillRect(0, height - speedBarHeight, width * simSpeed, speedBarHeight);
    mainCtx.globalAlpha = 1;
  }
  
  trailsCtx.resetTransform();
  mainCtx.resetTransform();
}

const currentSkyColor = { r: 0, g: 0, b: 0 };
const targetSkyColor = { r: 0, g: 0, b: 0 };

function colorSky(speed) {
  const maxSkySaturation = 30;
  const maxStarCount = 500;
  let totalStarCount = 0;
  
  targetSkyColor.r = 0;
  targetSkyColor.g = 0;
  targetSkyColor.b = 0;
  
  COLOR_CODES.forEach(color => {
    const tuple = COLOR_TUPLES[color];
    const count = Star.active[color].length;
    totalStarCount += count;
    targetSkyColor.r += tuple.r * count;
    targetSkyColor.g += tuple.g * count;
    targetSkyColor.b += tuple.b * count;
  });
  
  const intensity = Math.pow(Math.min(1, totalStarCount / maxStarCount), 0.3);
  const maxColorComponent = Math.max(1, targetSkyColor.r, targetSkyColor.g, targetSkyColor.b);
  
  targetSkyColor.r = targetSkyColor.r / maxColorComponent * maxSkySaturation * intensity;
  targetSkyColor.g = targetSkyColor.g / maxColorComponent * maxSkySaturation * intensity;
  targetSkyColor.b = targetSkyColor.b / maxColorComponent * maxSkySaturation * intensity;
  
  const colorChange = 10;
  currentSkyColor.r += (targetSkyColor.r - currentSkyColor.r) / colorChange * speed;
  currentSkyColor.g += (targetSkyColor.g - currentSkyColor.g) / colorChange * speed;
  currentSkyColor.b += (targetSkyColor.b - currentSkyColor.b) / colorChange * speed;
  
  appNodes.canvasContainer.style.backgroundColor = `rgb(${currentSkyColor.r | 0}, ${currentSkyColor.g | 0}, ${currentSkyColor.b | 0})`;
}

mainStage.addEventListener('ticker', update);

function createParticleArc(start, arcLength, count, randomness, particleFactory) {
  const angleDelta = arcLength / count;
  const end = start + arcLength - (angleDelta * 0.5);
  
  if (end > start) {
    for (let angle = start; angle < end; angle = angle + angleDelta) {
      particleFactory(angle + Math.random() * angleDelta * randomness);
    }
  } else {
    for (let angle = start; angle > end; angle = angle + angleDelta) {
      particleFactory(angle + Math.random() * angleDelta * randomness);
    }
  }
}

// ç‰¹æ•ˆå‡½æ•°
function crossetteEffect(star) {
  const startAngle = Math.random() * PI_HALF;
  createParticleArc(startAngle, PI_2, 4, 0.5, (angle) => {
    Star.add(
      star.x,
      star.y,
      star.color,
      angle,
      Math.random() * 0.6 + 0.75,
      600
    );
  });
}

function floralEffect(star) {
  const startAngle = Math.random() * PI_HALF;
  createParticleArc(startAngle, PI_2, 24, 1, (angle) => {
    Star.add(
      star.x,
      star.y,
      star.color,
      angle,
      Math.pow(Math.random(), 0.45) * 2.4,
      1000 + Math.random() * 300,
      star.speedX,
      star.speedY
    );
  });
  
  BurstFlash.add(star.x, star.y, 24);
}

function fallingLeavesEffect(star) {
  const startAngle = Math.random() * PI_HALF;
  createParticleArc(startAngle, PI_2, 12, 1, (angle) => {
    const newStar = Star.add(
      star.x,
      star.y,
      INVISIBLE,
      angle,
      Math.pow(Math.random(), 0.45) * 2.4,
      2400 + Math.random() * 600,
      star.speedX,
      star.speedY
    );
    newStar.sparkColor = COLOR.Gold;
    newStar.sparkFreq = 72;
    newStar.sparkSpeed = 0.28;
    newStar.sparkLife = 750;
    newStar.sparkLifeVariation = 3.2;
  });
  
  BurstFlash.add(star.x, star.y, 24);
}

function crackleEffect(star) {
  createParticleArc(0, PI_2, 10, 1.8, (angle) => {
    Spark.add(
      star.x,
      star.y,
      COLOR.Gold,
      angle,
      Math.pow(Math.random(), 0.45) * 2.4,
      300 + Math.random() * 200
    );
  });
}

// Shell ç±»
class Shell {
  constructor(options) {
    Object.assign(this, options);
    this.starLifeVariation = options.starLifeVariation || 0.125;
    this.color = options.color || randomColor();
    this.glitterColor = options.glitterColor || this.color;
    
    if (!this.starCount) {
      const density = options.starDensity || 1;
      const scaledSize = this.size / 50 * density;
      this.starCount = scaledSize * scaledSize * 1.5;
    }
  }
  
  launch(position, launchHeight) {
    const { width, height } = mainStage;
    const hpad = 60;
    const vpad = 50;
    const minHeightPercent = 0.45;
    const minHeight = height - height * minHeightPercent;
    
    const launchX = position * (width - hpad * 2) + hpad;
    const launchY = height;
    const burstY = minHeight - (launchHeight * (minHeight - vpad));
    const launchDistance = launchY - burstY;
    
    const launchVelocity = Math.pow(launchDistance * 0.04, 0.64);
    const comet = this.comet = Star.add(
      launchX,
      launchY,
      typeof this.color === 'string' && this.color !== 'random' ? this.color : COLOR.White,
      Math.PI,
      launchVelocity * (this.horsetail ? 1.2 : 1),
      launchVelocity * (this.horsetail ? 100 : 400)
    );
    
    comet.heavy = true;
    comet.spinRadius = 0.78;
    comet.sparkFreq = 16;
    
    if (this.glitter === 'willow' || this.fallingLeaves) {
      comet.sparkFreq = 10;
      comet.sparkSpeed = 0.5;
      comet.sparkLife = 500;
      comet.sparkLifeVariation = 3;
    }
    
    if (this.color === INVISIBLE) {
      comet.sparkColor = COLOR.Gold;
    }
    
    comet.onDeath = comet => this.burst(comet.x, comet.y);
  }
  
  burst(x, y) {
    const speed = this.size / 96;
    let color, onDeath, sparkFreq, sparkSpeed, sparkLife;
    let sparkLifeVariation = 0.25;
    
    if (this.crossette) onDeath = crossetteEffect;
    if (this.floral) onDeath = floralEffect;
    if (this.crackle) onDeath = crackleEffect;
    if (this.fallingLeaves) onDeath = fallingLeavesEffect;
    
    if (this.glitter === 'light') {
      sparkFreq = 200;
      sparkSpeed = 0.25;
      sparkLife = 600;
    } else if (this.glitter === 'medium') {
      sparkFreq = 100;
      sparkSpeed = 0.36;
      sparkLife = 1400;
    } else if (this.glitter === 'heavy') {
      sparkFreq = 42;
      sparkSpeed = 0.62;
      sparkLife = 2800;
    } else if (this.glitter === 'streamer') {
      sparkFreq = 20;
      sparkSpeed = 0.75;
      sparkLife = 800;
    } else if (this.glitter === 'willow') {
      sparkFreq = 72;
      sparkSpeed = 0.28;
      sparkLife = 1000;
      sparkLifeVariation = 3.4;
    }
    
    const starFactory = angle => {
      const star = Star.add(
        x,
        y,
        color || randomColor(),
        angle,
        Math.pow(Math.random(), 0.45) * speed,
        this.starLife + Math.random() * this.starLife * this.starLifeVariation,
        this.horsetail && this.comet && this.comet.speedX,
        this.horsetail && this.comet && this.comet.speedY
      );

      star.onDeath = onDeath;

      if (this.glitter) {
        star.sparkFreq = sparkFreq;
        star.sparkSpeed = sparkSpeed;
        star.sparkLife = sparkLife;
        star.sparkLifeVariation = sparkLifeVariation;
        star.sparkColor = this.glitterColor;
        star.sparkTimer = Math.random() * star.sparkFreq;
      }
    };
    
    if (typeof this.color === 'string') {
      if (this.color === 'random') {
        color = null;
      } else {
        color = this.color;
      }
      
      if (this.ring) {
        const ringStartAngle = Math.random() * Math.PI;
        const ringSquash = Math.pow(Math.random(), 0.45) * 0.992 + 0.008;
        
        createParticleArc(0, PI_2, this.starCount, 0, angle => {
          const initSpeedX = Math.sin(angle) * speed * ringSquash;
          const initSpeedY = Math.cos(angle) * speed;
          const newSpeed = Math.sqrt(initSpeedX * initSpeedX + initSpeedY * initSpeedY);
          const newAngle = Math.atan2(initSpeedY, initSpeedX) + ringStartAngle;
          
          const star = Star.add(
            x,
            y,
            color,
            newAngle,
            newSpeed,
            this.starLife + Math.random() * this.starLife * this.starLifeVariation
          );
          
          if (this.glitter) {
            star.sparkFreq = sparkFreq;
            star.sparkSpeed = sparkSpeed;
            star.sparkLife = sparkLife;
            star.sparkLifeVariation = sparkLifeVariation;
            star.sparkColor = this.glitterColor;
            star.sparkTimer = Math.random() * star.sparkFreq;
          }
        });
      } else {
        createParticleArc(0, PI_2, this.starCount, 1, starFactory);
      }
    } else if (Array.isArray(this.color)) {
      let start, start2, arc;
      if (Math.random() < 0.5) {
        start = Math.random() * Math.PI;
        start2 = start + Math.PI;
        arc = Math.PI;
      } else {
        start = 0;
        start2 = 0;
        arc = PI_2;
      }
      
      color = this.color[0];
      createParticleArc(start, arc, this.starCount/2, 1, starFactory);
      color = this.color[1];
      createParticleArc(start2, arc, this.starCount/2, 1, starFactory);
    }
    
    if (this.pistil) {
      const innerShell = new Shell({
        size: this.size * 0.5,
        starLife: this.starLife * 0.7,
        starLifeVariation: this.starLifeVariation,
        starDensity: 1.65,
        color: this.pistilColor,
        glitter: 'light',
        glitterColor: this.pistilColor === COLOR.Gold ? COLOR.Gold : COLOR.White
      });
      innerShell.burst(x, y);
    }
    
    if (this.streamers) {
      const innerShell = new Shell({
        size: this.size,
        starLife: this.starLife * 0.8,
        starLifeVariation: this.starLifeVariation,
        starCount: Math.max(6, this.size / 45) | 0,
        color: COLOR.White,
        glitter: 'streamer'
      });
      innerShell.burst(x, y);
    }
    
    BurstFlash.add(x, y, this.size / 8);
  }
}

const BurstFlash = {
  active: [],
  _pool: [],
  _new() {
    return {};
  },
  add(x, y, radius) {
    const instance = this._pool.pop() || this._new();
    instance.x = x;
    instance.y = y;
    instance.radius = radius;
    this.active.push(instance);
    return instance;
  },
  returnInstance(instance) {
    this._pool.push(instance);
  }
};

function createParticleCollection() {
  const collection = {};
  COLOR_CODES_W_INVIS.forEach(color => {
    collection[color] = [];
  });
  return collection;
}

const Star = {
  drawWidth: 3,
  airDrag: 0.98,
  airDragHeavy: 0.992,
  active: createParticleCollection(),
  _pool: [],
  _new() {
    return {};
  },
  add(x, y, color, angle, speed, life, speedOffX, speedOffY) {
    const instance = this._pool.pop() || this._new();
    instance.heavy = false;
    instance.x = x;
    instance.y = y;
    instance.prevX = x;
    instance.prevY = y;
    instance.color = color;
    instance.speedX = Math.sin(angle) * speed + (speedOffX || 0);
    instance.speedY = Math.cos(angle) * speed + (speedOffY || 0);
    instance.life = life;
    instance.spinAngle = Math.random() * PI_2;
    instance.spinSpeed = 0.8;
    instance.spinRadius = 0;
    instance.sparkFreq = 0;
    instance.sparkSpeed = 1;
    instance.sparkTimer = 0;
    instance.sparkColor = color;
    instance.sparkLife = 750;
    instance.sparkLifeVariation = 0.25;
    this.active[color].push(instance);
    return instance;
  },
  returnInstance(instance) {
    instance.onDeath && instance.onDeath(instance);
    instance.onDeath = null;
    this._pool.push(instance);
  }
};

const Spark = {
  drawWidth: 0.75,
  airDrag: 0.9,
  active: createParticleCollection(),
  _pool: [],
  _new() {
    return {};
  },
  add(x, y, color, angle, speed, life) {
    const instance = this._pool.pop() || this._new();
    instance.x = x;
    instance.y = y;
    instance.prevX = x;
    instance.prevY = y;
    instance.color = color;
    instance.speedX = Math.sin(angle) * speed;
    instance.speedY = Math.cos(angle) * speed;
    instance.life = life;
    this.active[color].push(instance);
    return instance;
  },
  returnInstance(instance) {
    this._pool.push(instance);
  }
};

// ==================== ä¸»ç¨‹åºå…¥å£ ====================
document.addEventListener('DOMContentLoaded', function() {
  // è·å–DOMå…ƒç´ 
  const startBtn = document.getElementById('startBtn');
  const audio = document.getElementById('myAudio');
  
  // åœ¨é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–ç²’å­æ–‡å­—ç³»ç»Ÿ
  ParticleTextSystem.init();
  
  // å¯åŠ¨æŒ‰é’®ç‚¹å‡»äº‹ä»¶
  startBtn.addEventListener('click', function() {
    // éšè—å¯åŠ¨æŒ‰é’®
    startBtn.style.display = 'none';
    
    // åˆå§‹åŒ–çƒŸèŠ±ç³»ç»Ÿ
    initFireworks();
    
    // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
    audio.play().catch(e => {
      console.log("è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»é¡µé¢ä»»æ„ä½ç½®å¼€å§‹æ’­æ”¾éŸ³ä¹");
    });
    
    // å»¶è¿Ÿ1ç§’åå¼€å§‹ç²’å­æ–‡å­—åŠ¨ç”»ï¼Œè®©çƒŸèŠ±å…ˆå¼€å§‹
    setTimeout(function() {
      ParticleTextSystem.startCountdownAndBlessings();
    }, 1000);
  });
  
  // é¡µé¢ç‚¹å‡»äº‹ä»¶ï¼Œç”¨äºå¤„ç†è‡ªåŠ¨æ’­æ”¾ç­–ç•¥
  document.addEventListener('click', function() {
    if (audio.paused) {
      audio.play();
    }
  });
});
</script>
</body>
</html>